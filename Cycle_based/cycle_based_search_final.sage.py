
# This file was *autogenerated* from the file ./cycle_based_search_final.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_0x1 = Integer(0x1); _sage_const_8 = Integer(8); _sage_const_16 = Integer(16); _sage_const_34 = Integer(34)#!/usr/bin/env sage
#this code supports python2.x only
from sage.all import *
from sage.crypto.boolean_function import BooleanFunction
from sage.crypto.sbox import SBox
import copy
import sys
sys.path.append('../sboxes_info/')
from sboxes import *
import math

#Analysis Threshold
ANALYSIS_BIT_RANGE = _sage_const_34 

#General Information
ALG_NAME = ""
S_BOX  = []
S_BOX_CARDINALITY = _sage_const_0 
S_BOX_BIT_SIZE = _sage_const_0 
S_BOX_BOOLEANS  = []


def set_sbox():
    for i in range(len(SBOXES)):
        print ("%s" % (SBOXES[i][_sage_const_0 ]))
    chosen = raw_input("> Which S-Box?(e.g., PRESENT):")
    
    global ALG_NAME
    global S_BOX
    global S_BOX_CARDINALITY
    global S_BOX_BIT_SIZE

    chosen_idx = -_sage_const_1 
    for i in range(len(SBOXES)):
        if (SBOXES[i][_sage_const_0 ] == chosen) or (SBOXES[i][_sage_const_0 ] == chosen.upper()):
            chosen_idx = i
            ALG_NAME = SBOXES[i][_sage_const_0 ]
            S_BOX = SBOXES[i][_sage_const_1 ]
            S_BOX_CARDINALITY = len(SBOXES[i][_sage_const_1 ])
            S_BOX_BIT_SIZE = S_BOX_CARDINALITY.bit_length() - _sage_const_1 

    if chosen_idx == -_sage_const_1 :
        print ("error : the S-Box(%s) does not exist" %chosen.upper())

def is_nonlinear_invariant(S_Box, nonlinear_invariant):
    tt = nonlinear_invariant.truth_table(format='int')
    init = tt[_sage_const_0 ] ^ tt[S_Box[_sage_const_0 ]]
    flag = _sage_const_0 
    for x in range(_sage_const_1 ,len(S_Box)):
        if tt[x] ^ tt[S_Box[x]] != init:
            flag = _sage_const_1 
    if flag == _sage_const_1 :
        return False
    else:
        return True

def get_alg_degree_from_ANF(ANF_str):
    ANF_mono_list =  ANF_str.split(' + ')
    return ANF_mono_list[_sage_const_0 ].count('x')

#Set S-Box
set_sbox()

#Set Ring
if S_BOX_BIT_SIZE == _sage_const_3 :
    R = BooleanPolynomialRing(_sage_const_3 , names=('x2', 'x1', 'x0',)); (x2, x1, x0,) = R._first_ngens(3)
    MONOMIALS = monomials([x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
elif S_BOX_BIT_SIZE == _sage_const_4 :
    R = BooleanPolynomialRing(_sage_const_4 , names=('x3', 'x2', 'x1', 'x0',)); (x3, x2, x1, x0,) = R._first_ngens(4)
    MONOMIALS = monomials([x3,x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
elif S_BOX_BIT_SIZE == _sage_const_5 :
    R = BooleanPolynomialRing(_sage_const_5 , names=('x4', 'x3', 'x2', 'x1', 'x0',)); (x4, x3, x2, x1, x0,) = R._first_ngens(5)
    MONOMIALS = monomials([x4,x3,x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
elif S_BOX_BIT_SIZE == _sage_const_6 :
    R = BooleanPolynomialRing(_sage_const_6 , names=('x5', 'x4', 'x3', 'x2', 'x1', 'x0',)); (x5, x4, x3, x2, x1, x0,) = R._first_ngens(6)
    MONOMIALS = monomials([x5,x4,x3,x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
elif S_BOX_BIT_SIZE == _sage_const_7 :
    R = BooleanPolynomialRing(_sage_const_7 , names=('x6', 'x5', 'x4', 'x3', 'x2', 'x1', 'x0',)); (x6, x5, x4, x3, x2, x1, x0,) = R._first_ngens(7)
    MONOMIALS = monomials([x6,x5,x4,x3,x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
elif S_BOX_BIT_SIZE == _sage_const_8 :
    R = BooleanPolynomialRing(_sage_const_8 , names=('x7', 'x6', 'x5', 'x4', 'x3', 'x2', 'x1', 'x0',)); (x7, x6, x5, x4, x3, x2, x1, x0,) = R._first_ngens(8)
    MONOMIALS = monomials([x7,x6,x5,x4,x3,x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
elif S_BOX_BIT_SIZE == _sage_const_16 :
    R = BooleanPolynomialRing(_sage_const_16 , names=('x15', 'x14', 'x13', 'x12', 'x11', 'x10', 'x9', 'x8', 'x7', 'x6', 'x5', 'x4', 'x3', 'x2', 'x1', 'x0',)); (x15, x14, x13, x12, x11, x10, x9, x8, x7, x6, x5, x4, x3, x2, x1, x0,) = R._first_ngens(16)
    MONOMIALS = monomials([x15,x14,x13,x12,x11,x10,x9,x8,x7,x6,x5,x4,x3,x2,x1,x0],[_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,_sage_const_2 ])
else:
    print("The bit size of the S-box is not supported")
    exit


TMP_S_BOX = range(S_BOX_CARDINALITY)
for i in range(len(S_BOX)):
    TMP_S_BOX[i] = S_BOX[i] + _sage_const_1 
P = Permutation(TMP_S_BOX)

CYCLES = P.to_cycles()
NUM_CYCLES = len(CYCLES)
CYCLE_LENGTHS = range(NUM_CYCLES)
AT_LEAST_ONE_ODD_FLAG = _sage_const_0 

for i in range(len(CYCLES)):
    CYCLES[i] = list(CYCLES[i])
    for j in range(len(CYCLES[i])):
        CYCLES[i][j] -=_sage_const_1  
    CYCLE_LENGTHS[i] = len(CYCLES[i])
    if (CYCLE_LENGTHS[i] & _sage_const_0x1 ) != _sage_const_0 :
        AT_LEAST_ONE_ODD_FLAG = _sage_const_1 

print("The length of each cycle : "),(CYCLE_LENGTHS)
#start computing

_0_BASIS = range(NUM_CYCLES)
for i in range(NUM_CYCLES):
    Boolean_Table = range(S_BOX_CARDINALITY)
    for j in range(S_BOX_CARDINALITY):
        if j in CYCLES[i]:
            Boolean_Table[j] = _sage_const_1 
        else:
            Boolean_Table[j] = _sage_const_0 
    _0_BASIS[i] = BooleanFunction(Boolean_Table)
    if is_nonlinear_invariant(S_BOX, _0_BASIS[i]) is not True:
            print("Warning! "), (_0_BASIS[i].algebraic_normal_form()), ("is not a nonlinear invariant but it is got.")

#S-Box(x(n-1), x(n-2), ..., x0)
NUM_NON_INVARIANT = _sage_const_0 
NUM_NON_INVARIANT_WITH_LINEAR_STRUCTURE = _sage_const_0 
NUM_BALANCED_NON_INVARIANT_WITH_LINEAR_STRUCTURE = _sage_const_0 

if AT_LEAST_ONE_ODD_FLAG == _sage_const_1 :
    NUM_NON_INVARIANT = _sage_const_2 **(NUM_CYCLES)
else:
    NUM_NON_INVARIANT = _sage_const_2 **(NUM_CYCLES + _sage_const_1 ) 

print ("== Nonlinear Invariants Info of %s" %ALG_NAME)
if AT_LEAST_ONE_ODD_FLAG == _sage_const_0 :
    print ("Every cycle has the even legnth.")
    print ("Therefore, nonlinear invariants g such that g(x) + g(sbox(x)) = 1 are included.")
else:
    print ("At least one cycle has the odd length.")
    print ("Therefore, nonlinear invariants g such that g(x) + g(sbox(x)) = 1 are *NOT* included.")
print ("# of Nonlinear Invariants : %d(=%d)" % (NUM_NON_INVARIANT,math.log(NUM_NON_INVARIANT,_sage_const_2 )))

#From here : Optional up to # of nonlinear invariants
if NUM_CYCLES < ANALYSIS_BIT_RANGE:
    i = _sage_const_0 
    while i < _sage_const_2 **NUM_CYCLES:
        K = BooleanFunction(x0 + x0) # here "0"
        chosen_vec = list(format(i, 'b').zfill(NUM_CYCLES))
        for j in range(NUM_CYCLES):
            if chosen_vec[j] == '1':
                K = K + _0_BASIS[j]        
        #check if it has the linear structure
        if K.has_linear_structure():
            NUM_NON_INVARIANT_WITH_LINEAR_STRUCTURE = NUM_NON_INVARIANT_WITH_LINEAR_STRUCTURE + _sage_const_1 
            #check if it is balanced
            if K.is_balanced():
                NUM_BALANCED_NON_INVARIANT_WITH_LINEAR_STRUCTURE = NUM_BALANCED_NON_INVARIANT_WITH_LINEAR_STRUCTURE +_sage_const_1 
        i = i + _sage_const_1 

    if AT_LEAST_ONE_ODD_FLAG == _sage_const_0 :
        i = _sage_const_0 
        while i < _sage_const_2 **NUM_CYCLES:
            Boolean_Table = range(S_BOX_CARDINALITY)
            start_bit_vec = list(format(i, 'b').zfill(NUM_CYCLES))
            for j in range(NUM_CYCLES):
                start_bit_vec[j] = int(start_bit_vec[j])
            for j in range(NUM_CYCLES):
                for k in CYCLES[j]:
                    Boolean_Table[k] = start_bit_vec[j]
                    start_bit_vec[j] = start_bit_vec[j] ^ _sage_const_1  #alternating
            K = BooleanFunction(Boolean_Table)
            #check if it has the linear structure
            if K.has_linear_structure():
                NUM_NON_INVARIANT_WITH_LINEAR_STRUCTURE = NUM_NON_INVARIANT_WITH_LINEAR_STRUCTURE + _sage_const_1 
                #check if it is balanced
                if K.is_balanced():
                    NUM_BALANCED_NON_INVARIANT_WITH_LINEAR_STRUCTURE = NUM_BALANCED_NON_INVARIANT_WITH_LINEAR_STRUCTURE +_sage_const_1 
            i = i + _sage_const_1 
    print ("# of Nonlinear Invariants with Linear Structure : %d" % NUM_NON_INVARIANT_WITH_LINEAR_STRUCTURE)
    print ("# of Balanced Nonlinear Invariants with Linear Structure : %d" % NUM_BALANCED_NON_INVARIANT_WITH_LINEAR_STRUCTURE)
else:
    print("# of nonlinear invariants is too large to analyze.")  

